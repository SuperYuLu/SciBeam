# slowBeamLib --- 
# 
# Filename: slowBeamLib.py
# Description:
#           This python3 script is a module of functions to be used
#         in the beam experiment. It is aimed to be used with exp
#         files generated by our LabView program, specifically .lvm
#         files.
#           Functions include auto search file name for keywrod speci
#         -fied by regular expression str, auto find data index bounds,
#         auto find peak region in a data file, auto gaussian fit, calcu
#         -late wire detector scan entrainment number, calculate time-of
#         -flight speed and linear fitting, generate plots for a single
#         or conbined time-of-flight plot, etc.
#           To use this library, under python3 environment 'from slowBeamLib
#         import *' will import all functions debuged and ready to be used.
#         note that functions under testing will not be imported by this
#         method. 
# 
# Author:    Yu Lu
# Email:     yulu@utexas.edu
# Github:    https://github.com/SuperYuLu 
# 
# Created: Tue Dec 6 14:32:42 2017 (-0500)
# Version: 3.4
# Last-Updated: Mon Jul 30 20:38:37 2018 (-0500)
#           By: yulu
#     Update #: 1766
#
# Version History:
#        2.0:     Change name from Li_Wire_scan.py to slowBeanLib.py
#        2.1:     Added function 'tofPlot'
#        2.2:     Added doc strings for functions 
#        2.3:     Added function main() to print the manual of all functions 
#        2.4:     Added function calcTransverseScan 
#        2.5:     Added functions doubleGaus, fitDoubldGaus
#        2.6:     Change calcuWireScan gaussian fit integrate entrainNum to cover 4 sigma region   
#        2.6.1:   Fixed an error with entrainment number calculation in function calcuWireScan, when fitTOF = True 
#        2.7:     20170901, add function 'entrainParaScanTOF'  
#        2.8:     add gaus_noOffset, Modified gaussfit with optional offset = False
#        2.8.1:   modified laser freq scan to take of absoption img, add invert input
#        2.9:     add loadFile function to enable easy file load and offset removal
#        3.0:     added ploty 3D interactive surface plot 
#        3.1:     add func plotAllInFolder and func load3dData
#        3.2:     add new feature 'plotTime' to func calcEntrainNum
#        3.3:     adding background noise substractions function by Logan Hillberry
#        3.4:     Last update on this lib, no future support, transfer to scibeam
# -*- coding: utf-8 -*-


import re
import os
import time
import warnings
import numpy as np
import matplotlib.pyplot as plt
import scipy.integrate as integrate
from scipy.optimize import curve_fit, leastsq
from scipy.fftpack import rfft, irfft
__all__ = [
    "man",
    "findFileNameKeyNum",
    "find_bounds_idx",
    "autoFindPeakBounds",
    "findGain",
    "gaus",
    "gaus_noOffset",
    "gausFit",
    "doubleGaus",
    "doubleGausFit",
    "ionizationProb",
    "bandPassFilter",
    "calcWireEntrainNum",
    "calcMultiPointZ",
    "tofPlot",
    "calcTransverseScan",
    "laserFreqScan",
    "entrainParaScanTOF",
    "plotly3d_surface",
    "load3dData",
    "plotAllInFolder",
    "wireNoiseModel",
    "calcScanningLaser",
    "backgroundSubtract",
    "warningMuter",
    "linePlotInOne",
    
    ]

__version__ = "3.0"

#=============================Assistance functions======================================
def man():
    """
    - Function: [no retrun] listFunctions()
    - Description: 
              This is a funtion to help list all functions in this library, and 
            their doc strings

    """
    print("Welcome! To use python3 *Slow Beam Library*:\n")
    print("==========================================")
    print("List of functions: ")
    print("---------------------")
    print(__all__)
    print("\nManual for functions:")
    print("---------------------")
    for func in __all__:
        print(eval(func+".__doc__"))
        print("\n\n")
        print("*****")
 
#==========================Decorators==========================================
def warningMuter(func):
    """
    Decorator function to mute possible runtime warning of divided by 0
    usually needed for gaussian fitting of some margin data
    """
    def wrapper(*args, **kwargs):
        with warnings.catch_warnings():
            warnings.filterwarnings('ignore')
            return func(*args, **kwargs)
    return wrapper 
            


#=========================Main Functions============================================       
def findFileNameKeyNum(regStr, path):
    """
    - Function: [float, list]keyNum = findFileNameKeyNum([str]regStr, [str]path)
    - Description: 
              Search numbers in the filename under the folder specified by 'path', with search 
            rules given by regular expression 'regStr'. The function will automatically find whether 
            the key number is float number or int. 
    - Input: 
            - regStr: [string] regular expression for keyword number searching
            - path: [string] String for searching folder name, remember to include '/' at the end
    - Output: 
            - keyNum: [float or int, list] search result, list of float numbers. 
    """
    
    key = list({re.findall(regStr, x)[0] for x in [y for y in os.listdir(path)] if not re.findall(regStr, x) == []})
    if sum(list(map(lambda x: len(re.findall('\d+', x)), key))) > len(key): # Numbers are float
        keyNum = sorted([float(re.findall('-?\d+?\.\d+|\d+', x)[0]) for x in key])
    else:
        keyNum = sorted([int(re.findall('-?\d+', x)[0]) for x in key])

    return keyNum



def find_bounds_idx(data, lowerBound, upperBound):
    """
    - Function: [int]lb,[int]ub = find_bounds_idx([array, float]data, [int]lowerBound, [int]upperBound)
    - Description:
              This function works for time of flight measurement. Given time lower bound and upper bound
            in microseconds, it searches the data array(1D of 2D) for the bound times and return the 
            corresponding index for lower bound and upper bound. 
    - Input: 
            - data: [1D/2D array, float] Experiment data array for a single time-of-flight measurement
                    with dimension NX1 or NX2, rows for different data point, colume 0 for time(s)  and 
                    column 1 for measured data. 
            - lowerBound: [int] Time in microseconds for the lower bound of data interested.
            - upperBound: [int] Time in microseconds for the upper bound of data interested.
    - Output: 
            - lb: [int] index for the lower bound time in the data array.
            - ub: [int] index for the upper bound time in the data array.
    """
    
    times = data[:,0] if  len(data.shape) > 1 else data
    lb = np.argmin(abs(times*1e6 - lowerBound))
    ub = np.argmin(abs(times*1e6 - upperBound))
    return (lb, ub)

def autoFindPeakBounds(data): 
    """
    - Function: [int]lowerBound, [int]upperBound = autoFindPeakBounds([1D/2D array] data)
    - Description: 
              This function is to find the peak regin in a time-of-flight data. Note that only use this function
            when you are sure that the peak exists and dominates the data array. The function work in the way 
            that it will find the maximium as the peak top, then find FWHM, chose the peak range as the peak max
            index +- 3 FWHM range. Returns the lower bound and upper bound index based on above description.
    - Input:
            - data: [1D/2D array] Array the time-of-flight data. If its 2D, then column 0 should be the time, and 
                    column 1 should be the measured signal value. If its 1Dm then it has to be the array of the 
                    measurement signal value, not the time. 
    - Output: 
            - lowerBound: [int] The index of lower bound peakd region
            - upperBound: [int] The index of upper bound peakd region
    """
    
    dim = len(data.shape) # dimension of the data array (1D or 2D)
    d = data[:,1] if dim > 1 else data
    peakIdx = np.argmax(d)
    peak = d[peakIdx]
    halfMax = peak / 2
    lowerHalf = np.argmin(abs(d[:peakIdx] - halfMax))
    upperHalf = peakIdx + np.argmin(abs(d[peakIdx:] - halfMax))
    fwhmIdx = upperHalf - lowerHalf
    
    lowerBound = lowerHalf - 3 * fwhmIdx
    upperBound = upperHalf + 3 * fwhmIdx
    if lowerBound < 0 or upperBound < 0:
        print('***Bound idx negative ! There probably is not peak !***\nUse auto finder only when you know there is peak!')
    return lowerBound, upperBound

def findGain(configFile):
    """
    -Function: [float]gain = findGain([str]configFile)
    -Description: 
             This function is used to auto search and calculate the conbined gain of Femto and SRS amplifier, from the
           specified file 'configFile'. It works in the way that the keyword 'fempto gain' and 'srs gain' will first
           be searched through regular expression, based their location in the config file find the corresponding gain
           value, then calculate the total gain of amplifiers as gain = femto gain x srs gain. It returns the calculated
           gain value. 
    - Input: 
            configFile: [string] The config filename, include the path leading to it. 
    - Output: 
            gain: [float] The calculated gain value. 
    """

    femtoGain = '0'
    srsGain = '0'
    try:
        with open(configFile, 'r') as conf:
            content = conf.read()
            femtoGain = re.findall('\d+\.\d+', re.findall('Femto Gain.+\d+\n', content)[0])[0] if len(re.findall('Femto Gain.+\d+\n', content)) else -1
            srsGain = re.findall('\d+\.\d+', re.findall('SRS Gain.+\d+\n', content)[0])[0] if len(re.findall('Femto Gain.+\d+\n', content)) else -1
    except IOError:
        print('The config file you provided can not be found ! \nAsk Yu Lu for help if you cannot make it work!')
    except EOFError:
        print("End of file, not keywords 'Femto Gain' or 'SRS Gain' found! ")
    gain = float(femtoGain) * float(srsGain)
    
    return gain


def gaus(x, a, x0, sigma, y0 = 0):
    """
    - Function: [function] = gaus([float]x, [float]a, [float]x0, [float]sigma, [float]y0 = 0)
    - Description: 
              This function defines the 1D gaussian function, with given peak amplitude, center, 
            standard diviation, and offset. return the calculated value of gaussain function.
            This function will be used by the function 'gausFit', but can also by used alone.
            Note that this function is not normalized to unit.
    - Input: 
            - x: [float] variable of the gaussian function, can be a single value or array.
            - a: [float] amplitude of the gaussian function
            - x0: [float] the average of variable, mean value for gaussian function
            - sigma: [float] the standard diviation of gaussian function 
            - y0: [float] y offset
    - output: 
            - value calculated from gaussian function, can be a single value or array.
    """
    
    return a * np.exp(-(x - x0)**2 / (2 * sigma**2)) + y0

def gaus_noOffset(x, a, x0, sigma):
    """
    - Function: [function] = gaus([float]x, [float]a, [float]x0, [float]sigma, [float]y0 = 0)
    - Description: 
              This function defines the 1D gaussian function, with given peak amplitude, center, 
            standard diviation, and offset. return the calculated value of gaussain function.
            This function will be used by the function 'gausFit', but can also by used alone.
            Note that this function is not normalized to unit.
    - Input: 
            - x: [float] variable of the gaussian function, can be a single value or array.
            - a: [float] amplitude of the gaussian function
            - x0: [float] the average of variable, mean value for gaussian function
            - sigma: [float] the standard diviation of gaussian function 
    - output: 
            - value calculated from gaussian function, can be a single value or array.
    """
    
    return a * np.exp(-(x - x0)**2 / (2 * sigma**2))

def gausFit(x, y, offset = False):
    """
    - Functions: [float, array]popt, [float, array]pcov = gausFit([2D array]data)
    - Description:
              This function is to fit data with 1D gausian equation:
                  y = a * exp((x - x0)^2 / (2 * sigma)) + y0
            it's calling funciton gaus and curve_fit (from scipy.optimize lib) to fit the 
            data. Sometimes (merely) it cannot find the optimized prarameters to fit the 
            data, that could be due to the range of peak giving in variable 'data'. It returns
            optimized parameters and their error.
    - Input:
            - x, y: 2D array, column gives x, while column gives y
    - Output: 
            - popt: [float,array] array of optmized data [a, x0, sigma, y0]
            - pcov: [float, array] covariant of the corresponding optmized data 
    
    """
    idxMax = np.argmax(y)
    a0 = y[idxMax]
    x0 = x[idxMax]
    
    halfWidth = x[idxMax + np.argmin(abs(y[idxMax:] - a0 / 2))] - x[idxMax]
    if offset:
        y0 = 0
        errorFunc = lambda p, x, y: (gaus(x, *p) - y)
        popt, pcov, infodic, mesg, ier = leastsq(errorFunc, [a0, x0, halfWidth, y0], full_output = True, args = (x, y))
    else:
        errorFunc = lambda p, x, y: (gaus_noOffset(x, *p) - y)
        popt, pcov, infodic, mesg, ier = leastsq(errorFunc, [a0, x0, halfWidth], full_output = True, args = (x, y))
    if ier < 0:
        print("Gaussian fit failed ")
    return popt, pcov

# Old fitting functions, low efficiency, not used any more
def gausFit_Old(data, y = 0):
    """
    - Functions: [float, array]popt, [float, array]pcov = gausFit([2D array]data)
    - Description:
              This function is to fit data with 1D gausian equation:
                  z = a * exp((x - x0)^2 / (2 * sigma)) + y0
            it's calling funciton gaus and curve_fit (from scipy.optimize lib) to fit the 
            data. Sometimes (merely) it cannot find the optimized prarameters to fit the 
            data, that could be due to the range of peak giving in variable 'data'. It returns
            optimized parameters and their error.
    - Input:
            - data: 2D array, column gives x, while column gives z
    - Output: 
            - popt: [float,array] array of optmized data [a, x0, sigma, y0]
            - pcov: [float, array] covariant of the corresponding optmized data 
    
    """
    if type(y) == np.ndarray:
        temp = np.zeros([len(y),2])
        temp[:,0] = data
        temp[:,1] = y
        data = temp
    idxMax = np.argmax(data[:,1])
    a = data[idxMax, 1]
    x0 = data[idxMax, 0]
    halfWidth = data[idxMax + np.argmin(abs(data[idxMax:, 1] - a / 2)), 0] - data[idxMax, 0]
    #y0 = np.average(data[-100:, 1])
    popt, pcov = curve_fit(gaus, data[:,0], data[:,1], p0 = [a, x0, halfWidth])
    
    
    #n = len(data[:,0])    
    #mean = sum(data[:,0]*data[:,1])/n
    #sigma = np.sqrt(sum(data[:,1] * (data[:,0] - mean)**2)/n)
    #popt, pcov = curve_fit(gaus, data[:,0], data[:,1], p0 = [1, mean, sigma])
    
    return popt, pcov


def doubleGaus(x, a0, x0, sigma0, a1, x1, sigma1, y0 = 0):
    """
    - Function: doubleGaus([float]x, [float]a0, [float]x0, [float]sigma0, [float]a1, [float]x1, [float]sigma1, [flaot]y0=0)
    - Description:
              Double gaussian function with offset
              y = a0 * exp((x - x0)^2 / (2 * sigma0^2) + a1 * exp((x - x1)^2 / (2 * sigma1^2))
    - Input:
            - x: [float] input variable for the double gaussian function 
            - a0, a1: [float] Amplitude of the two gaussian peaks
            - x0, x1: [float] Peak center for the two gaussian peaks 
            - sigma0, sigma1: [float] sigma vlaues for the two gaussian peaks
            - y0: [float] y offset, optional, default y0 = 0
    - output
            Calculated double gaussian function
    """
    return a0 * np.exp(-(x - x0)**2/(2 * sigma0**2)) + a1 * np.exp(-(x - x1)**2 / (2 * sigma1 **2)) + y0

def doubleGausFit(x, y, guessPara):
    """
    - Function: [array]popt, [array]pcov = doubleGausFit([array]x, [array]y, [array]guessPara)
    - Description: 
              This function to fit the data with a double gaussian function. x, y are the corresponding x, y value of the 
            initial data and initial guess parameters. 
              This function is using least square method to fit the double gaussian function and get the fitting parameters.
    - Input: 
            - x: [array] input data x axis value 
            - y: [array] input data y axis value
            - guessPara: [array/list] initial guess parameter list[a0, x0, sigma0, a1, x1, sigma1, y0]
    - Output:
            - popt: [array] fitted parameter array [a0, x0, simga0, a1, x1, simga1]
            - pcov: [array] corresponding converiance of popt
              
    
    """
    errorFunc = lambda p, x, y: (doubleGaus(x, *p) - y)
    popt, pcov, infodic, mesg, ier= leastsq(errorFunc, guessPara, full_output= True ,args = (x, y))
    if ier < 0:
        print("Double gauss fit failed! ")
    return popt, pcov
    
def ionizationProb(wireVolt = 12):
    """
    - Function: [float]ionProb = ionizationProb([float]wireVolt = 12)
    - Description: 
              This function is to calculate the ionization probality of the hot wire 
            detector ionization. It based on Issac's meaaurement of the temperature 
            of the wire under different voltage, interpolate it with the input volte
            used in the experiment. Then calculate the ionization probablity based on 
            the ionization energy and work function. Returns the calculated probablity.
            By default wireVolt is set to 12V, which is the one we usually used. 
    - Input: 
            - wireVolt: [float] The voltage on the hot wire detector
    - Output: 
            - ionProb: [float] Ionization probablity
    
    """
    I = 5.392 #[ev] ionization potential of Li
    Phi = 4.96 #[ev] Work function of Rhenium 
    k = 8.617e-5 #[ev/K] Boltzmann const
    #e = 1.602e-19 #[C] electron charge
    
    # Wire detector temperature, done by Issac                
    volt = np.array([1.5, 2.5, 4.5, 6, 9, 11, 13])
    temperature = np.array([598, 871, 1135, 1314, 1505, 1607, 1733]) + 273 # K
    T = np.interp(wireVolt, volt, temperature) - 50 # Linear interpolation of temperature, not clear why there is -100, took form Kevin/Jianyong 
    ionProb = 1/ ( 1 + 2 * np.exp((I - Phi) / (k * T)))
    return ionProb


def bandPassFilter(data, tStep = 3.9999999999999998e-07, lowFreq = 0, highFreq = 1e4):
    yf = rfft(data[:,1])
    xf = np.linspace(0, 1 / tStep, len(yf))
    for i, z in enumerate(yf):
        if not lowFreq<= xf[i] < highFreq:
            yf[i] = 0
    iyf = irfft(yf)
    data[:,1] = iyf
    return(data)


def wireNoiseModel(x, a, b, c, d, g):
    return a * np.sin(b*x + c) + d*x + g

def backgroundSubtract(data, fitlb, fitub):
    """
    EXPERIMENTAL (L.H.)
    - Description:
        Used to remove low frequency noise from wire data
    """
    x = data[:, 0] 
    y = data[:, 1]
        # data for fitting noise
    dff = data[fitlb:fitub, :]
    dffx = dff[:, 0]
    dffy = dff[:, 1]
    #TODO: put func and list of func parameters into kwargs?
    # initial guess at fit parameters for a * sin(b*x + c) + d*x + g
    a = 0.04
    b = 5000.0
    c = 0
    d = 0.2
    g = -0.003
    errorFunc = lambda p, x, y: (wireNoiseModel(x, *p) - y)
    popt, pcov, infodic, mesg, ier = leastsq(errorFunc, [a, b, c, d, g], full_output = True, args = (dffx, dffy))
    noiseModel = lambda x: wireNoiseModel(x, *popt)
    yclean = y - noiseModel(x)
    dataClean = np.asarray([[x, y] for x, y in zip(x, yclean)])
    # plot raw data, noise fit, and cleaned data
    #fig = plt.figure(i)
    #ax1 = fig.add_subplot(1,2,1)
    #ax1.set_title(str(i+1))
    #ax2 = fig.add_subplot(1,2,2)
    #ax1.plot(x[fitlb:fitub], y[fitlb:fitub])
    #ax1.plot(x[fitlb:fitub], noiseModel(x[fitlb:fitub]))
    #ax2.plot(x[fitlb:fitub], yclean[fitlb:fitub])
    #plt.show()
    #plt.clf()
    return dataClean
    
    
@warningMuter
def calcWireEntrainNum(path, config, lowerBound, upperBound, plot = False, image = False,
                       fitTOF = False, fitScan = False, stepSize = 0.0315, beamVelocity = 0,subtractBackground=False,
                       debug = False, timePlot = False, noiseFilter = False, lowFreq = 0, highFreq = 1e4, cscale=(None, None)):
    """
    - Function: [float]entrainNum = calcWireEntrainNum([str]path, [str]config, [int]lowerBound, [int]upperBound
                                    [bool]plot = False, [bool]image = Flase, [bool]fit = False, [float]beamVelocity = 0,
                                    [tuple]cscale = (None, None))
    - Description: 
              This function is used with the wire scan data. It calculates the entrainment number
            for a wire scan measurement. All of the files have to be in a single folder, and this 
            folder should contain no other files from other measuremnt, otherwise the auto indexing 
            will be messed up. 
              It automatically finds the wire scan data file and the position of the corresponding 
            wire position (in inches), by using regular expression. It also automatically find the 
            gain of measurment by looking into the 'config' file. Based on measurement data, gain,
            ionization probality and detection probality. 
              The function provides optional parameters, users can decided if they want to plot the 
            scan result, scan image, fit gaussain or not. 
    - Input: 
            - path: [str] The path to the folder which has wire scan data 
            - config: [str] The config file which has measurement parameters, especially gain info.
            - lowerBound: [int] The lowerBound of data peak region in terms of micorseconds [us].
            - upperBound: [int] The upperBound of data peak region in terms of microseconds [us].
            - plot: [bool] Optional, decide wether to plot result or not.
                    True for plot, False (default) for no plot
            - image: [bool] Optional, decide wether or not plot imaging of the wire scan.
                     Note: in order to plot image, the value of 'plot' has to be set to 'True'.
                     True for ploting the image, False(default) for not ploting the image
            - fitScan: [bool] Decide wether to fit the wire scan with gaussian or not 
                   True to fit with gaussian, False(default) to not fit 
            - fitTOF: [bool] Decide wether to fit the tof signal for a single wire measurement with 
                   gaussian. By default its 'False'
            - stepSize: [float] inches, stepsize of the wire scan, default 0.0315 in
            - beamVelocity: [float] Optional, velocity of beam. This is used to add another axis 
                            on the image plot, to show the actually size of the cloud. If it is 
                            setted to 0(default), then this additional axis will not be added.
            - cscale: [tuple] Optional, lower and upper bound of image color bar, default is 
                      imshow default (min and max of data). Use elements of `None` inside the tuple 
                      for partial default.
    - Output: none                                              
    """
    
    detectProb = 0.3
    e = 1.602e-19 # C -Charge of electron
    ionProb = ionizationProb()
    gain = findGain(path + config)
    
    pos = findFileNameKeyNum('\d+\.\d*in', path)
    entrainNum = np.zeros((len(pos), 2))
    entrainNum[:,0] = pos
    
    for i, p in enumerate(pos):
        fileName = [x for x in os.listdir(path) if not re.findall('.*_APD3_stepper_'+str(p) + '.+lvm', x) == []][0]
        if debug:
            print('loading file: ' + fileName + '...')
        try:
            data = np.loadtxt(path + fileName, skiprows = 50)
        except ValueError:
            print("Probelmatic file: ", fileName)
            raise ValueError
        lb, ub = find_bounds_idx(data, lowerBound, upperBound)
        yOffset = np.average(data[lb - 30: lb, 1])
        #yOffset = np.average(data[lb - 20: lb, 1] + data[ub: ub+20, 1])
        tStep = data[1,0] - data[0,0]                     
        if subtractBackground:
            data = backgroundSubtract(data, ub, -1)
        data = data[lb:ub, :] # This has to go after possible substractBackground
        data[:,1] = data[:,1] - yOffset   
        if noiseFilter:
            data = bandPassFilter(data, tStep = tStep, lowFreq = lowFreq, highFreq = highFreq) 
            
        if fitTOF:
            popt_tof, pcov_tof = gausFit(data[:,0], data[:,1])
            #inteTOF = integrate.quad(lambda x:gaus(x, *popt_tof)/0.0315, data[0,0], data[-1,0])[0]
            inteTOF = integrate.quad(lambda x:gaus(x, *popt_tof), data[0,0], data[-1,0])[0]
            
        entrainNum[i,1] = inteTOF/(e*ionProb*gain*detectProb) if fitTOF else np.trapz(data[:,1],data[:,0])/(e*ionProb*gain*detectProb)
        totEntrainNum = entrainNum[:,1].sum()
                
        if image:

            if i == 0:
                imagePlot = np.zeros([len(pos), ub - lb])
                imagePlot[i, :] = data[:,1]/(e*ionProb*gain*detectProb) * stepSize * 25.4 * 1e-6#entrain num per area per us
            else:
                imagePlot[i, :] = data[:,1]/(e*ionProb*gain*detectProb) * stepSize * 25.4 * 1e-6
                
        if timePlot:
            if i == 0:
                timeSum = data
            else:
                timeSum[:,1] = timeSum[:,1] + data[:,1]
    
    if subtractBackground:
        print("\n**NOTE**: background subtraction is ON!")
        
    if noiseFilter:
        print("\n**NOTE**: noise band pass filter is ON!")
    # supplementary functions
    if fitScan:
        popt, pcov = gausFit(entrainNum[:,0], entrainNum[:,1])
        gausStart = popt[1] - 4 * popt[2] # 4 sigma
        gausEnd = popt[1] + 4 * popt[2] # 4 sigma 
        inteEntrainNum = integrate.quad(lambda x:gaus(x, *popt)/0.0315, gausStart, gausEnd)[0]
        print("\n=================================================")
        print('Integrated atom num (Gaussian 4 sigma): ', '{:2E}'.format(inteEntrainNum))
        print("Beam transverse center(Gaussian fit): {:1.3f} in".format(popt[1]))
        print('Beam FWHM (Gaussian fit): {a:1.3f} in'.format(a=2*np.sqrt(2 * np.log(2)) * popt[2]))
        print("=================================================")
        
    if plot:
        plt.figure()
        plt.plot(entrainNum[:,0], entrainNum[:,1], 'o', label = 'raw data\n' + str('{:.2e}'.format(totEntrainNum)))
        plt.xlabel('Wire scan position [in]')
        plt.ylabel('Atom number')
        plt.title('Wire scan entrainment number')
        if fitScan:
            gpos = np.linspace(gausStart, gausEnd, 100)
            plt.plot(gpos, gaus(gpos, *popt), 'r-', label = 'gaussian fit (4 sigma)\n' + str('{:.2e}'.format(inteEntrainNum)))
        plt.legend()

    
    if image:
        fig1 = plt.figure()
        ax1 =fig1.add_subplot(111)
        cax = ax1.imshow(imagePlot, 
                         extent = [data[0, 0] * 1e6, data[-1,0] * 1e6, pos[0],pos[-1] ],
                         origin = 'lower',
                         aspect = 'auto',
                         cmap = 'jet',
                         vmin = cscale[0],
                         vmax = cscale[1])
        ax1.set_xlabel('Time of flight [us]')
        ax1.set_ylabel('X position (wire) [in]')
        cbar = fig1.colorbar(cax)
        cbar.set_label('Atom number')
        if beamVelocity > 0:
            ax2 = ax1.twiny()
            ax2.set_xlim([0,  (data[-1,0] - data[0,0]) * beamVelocity * 1e3])
            ax2.set_xlabel(' Z position [mm]')
    
    if timePlot:
        fig2, ax2 = plt.subplots()
        ax2.plot(timeSum[:,0]*1e6, timeSum[:,1], '*-')
        ax2.set_xlabel('Time[us]')
        ax2.set_ylabel('Position summed signal')
        ax2.set_title('Wire scan time plot with sum on wire position')
        
    if fitScan or plot or image or timePlot:
        plt.show()
        
    if timePlot:
    
        return entrainNum, timeSum
    else:
        return entrainNum
    


def calcMultiPointZ(path, nozzleTemp, regStr ='\d+.\d*in.lvm', gasMass = 4, lowerBound = 0, upperBound = 0, plot = False, linearFit = True, calcTemp = False):
    """ 
    - Function: [no return] = calcMultiPointZ([str]path, [flot]nozzleTem, [int]gasMass = 4
                              [int]lowerBound = 0, [int]upperBound = 0, [bool]plot = False, [bool]linearFit = True)
    - Description:
               This functin is to analyze speed of beam from the data of 1D scan along the Z direction, either from
             laser, or from RGA, even wire detector. 
               It takes regular expression string to look for the position of measurement point, then load the 
             corresponding files, calcult the peak arrival time with and without gaussain fitting. Then use linear
             fit to fit the time VS position plot, to get the speed of the beam with error bar.
               Features like plot, linear fit could be turn on and off by set the values of corresponding boolean
    - Input:
            - path:[str] path to the measurement folder
            - nozzleTemp: temperature of nozzle 
            - regStr:[str] regular expresssion to search the position of measurement point from each file name 
                     by default, it uses inch as the position unite. as '\d+.\d*in.lvm'     
            - gasMass: [int] The mass of carrier gas in AMU, by default its 4 for helium 
            - lowerBound: [int] lowerBound time of the peak region in micorseconds [us], set to 0 by default, 
                          if both lowerBound and upperBound are 0, then this function will call 'autoFindPeakBounds'
                          function to find the index of the lower and upper bounds, but one has to make sure that 
                          there is peak exists.
            - upperBound: [int] upperBound time of the peak region in micorseconds [us], set to 0 by default, 
                          if both lowerBound and upperBound are 0, then this function will call 'autoFindPeakBounds'
                          function to find the index of the lower and upper bounds, but one has to make sure that 
                          the peak exsits.
            - plot: [bool] Decide wether to plot the time of arrival fiting plot. if true, plot, if flase (default)
                    don't plot. 
            - linearFit: [bool] Decide wether to do linear fit to the measurement tof or not. If true, do fit, if 
                    False (defualt), don't plot. 
            - calcTemp: [bool] Decide whether or not calculate the longitudinal temperature based on the tof. Default
                    False.
    - Output: none
        
        
    """
    position = findFileNameKeyNum(regStr, path) # in
    tArrivalNoGausFit = []
    tArrivalGausFit = []

    speedRatioNoFit = []
    speedRatioGausFit = []
    fwhmDirect = []
    fwhmGaus = []
    for i, pos in enumerate(position):
        
        fileName = [x for x in os.listdir(path) if not re.findall('_' + str(pos) + 'in.lvm', x) == []][0]
        print('...loading '+ fileName)
        data = np.loadtxt(path + fileName, skiprows = 50)
        lb,ub = autoFindPeakBounds(data) if (lowerBound + upperBound) == 0 else find_bounds_idx(data, lowerBound, upperBound)
        data = data[lb:ub, :]
        peakIdx = np.argmax(data[:,1])
        a = data[peakIdx, 1]
        t0 = data[peakIdx, 0]
        lh = np.argmin(abs(data[:peakIdx, 1] - a /2  ))
        hh = np.argmin(abs(data[peakIdx:, 1] - a /2)) + peakIdx
        fwhm = data[hh, 0] - data[lh, 0]
        
        # calculate peak arrival time and speed ratio
        tArrivalNoGausFit.append(data[np.argmax(data[:,1]), 0] * 1e6) # [us]
        popt, pcov = gausFit(data[:,0], data[:,1])
        tArrivalGausFit.append(popt[1] * 1e6)

        speedRatioGausFit.append( 2 * np.sqrt(np.log(2)) * popt[1] / (2 * np.sqrt(2 * np.log(2)) * popt[2])) # from gaussian fit    
        speedRatioNoFit.append( 2 * np.sqrt(np.log(2)) * t0 / fwhm) # from direct fwhm
        
        # Beam tof fwhm
        fwhmDirect.append(fwhm)
        fwhmGaus.append(2 * np.sqrt(2 * np.log(2)) * popt[2])
        
    # Calculate longitudinal velocity, multipoint or two point measurement 
    
    if linearFit: # For multi-point meausrement 
        linearVNoFit, cov1 = np.polyfit(position, tArrivalNoGausFit, 1, cov = 'True')
        linearVGausFit, cov2 = np.polyfit(position, tArrivalGausFit, 1, cov = 'True')
        linearSpeedNoFit  = 1 / linearVNoFit[0] * 0.0254 * 1e6
        linearSpeedGausFit = 1 / linearVGausFit[0] * 0.0254 * 1e6
        stdV = (linearSpeedNoFit)**2 *  np.sqrt(cov1[0,0]) * 1e-6 / 0.0254
        stdVFit = (linearSpeedNoFit)**2 *  np.sqrt(cov2[0,0]) * 1e-6 / 0.0254
        print('Beam velocity multi-point (w/o gaussian peak fit): ', linearSpeedNoFit, ' +- ', stdV, ' m/s')
        print('Beam velocity multi-point (w/ gaussian peak fit): ', linearSpeedGausFit, ' +- ', stdVFit, 'm/s')
    else: # For two-point measurement 
        twoPointSpeedNoGausFit = abs((position[-1] - position[0]) * 0.0254  / (tArrivalNoGausFit[-1] - tArrivalNoGausFit[0]) * 1e6)
        twoPointSpeedGausFit = abs((position[-1] - position[0]) * 0.0254  / (tArrivalGausFit[-1] - tArrivalGausFit[0]) * 1e6)
        print('Beam velocity 2 point measurement (w/o gaussian peak fit): ', twoPointSpeedNoGausFit, ' m/s')
        print('Beam velocity 2 point measurement (w/ gaussian peak fit): ', twoPointSpeedGausFit, 'm/s')
    
    
    
    if calcTemp:
        # Calculatie longitudinal temperature using the beam equation
        S_NoGausFit = np.average(speedRatioNoFit) # from direct difinition
        S_GausFit = np.average(speedRatioGausFit) # from gaussian fit
        zTemp_NoGausFit_Equation = nozzleTemp / (1 + 2 / 5 * S_NoGausFit**2 ) * 1e3 # mK
        zTemp_GausFit_Equation = nozzleTemp / (1 + 2 / 5 * S_GausFit**2 ) * 1e3 # mK
        
        zTemp_NoGausFit_Equation_std = nozzleTemp / (1 + 2 / 5 * S_NoGausFit**2)**2 * 4 / 5 * S_NoGausFit * np.std(speedRatioNoFit) * 1e3 # mK
        zTemp_GausFit_Equation_std = nozzleTemp / (1 + 2 / 5 * S_GausFit**2)**2 * 4 / 5 * S_GausFit * np.std(speedRatioGausFit) * 1e3 # mK
    
        print('Beam longitudinal temperature from the beam equation (w/o gaussian fit): ', zTemp_NoGausFit_Equation, ' +-', zTemp_NoGausFit_Equation_std, ' mK')
        print('Beam longitudinal temperature from the beam equation (w/ gaussian fit): ', zTemp_GausFit_Equation, ' +-', zTemp_GausFit_Equation_std, ' mK')
    
    #===============Testing feature 1, under development==================================
    
    # Calculation longitudinal temperature using velocity distribution
#    kb = 1.38e-23
#    u = 1.66e-27
#    linearT, cov3 = np.polyfit(position, np.array(tArrivalGausFit) + np.array(tSigma), 1, cov='True')
#    paraVSigma  = 1 / linearT[0] * 0.0254 * 1e6 - linearSpeedGausFit                             
#    stdParaVSigma = paraVSigma**2 * np.sqrt(cov3[0,0]) * 1e-6 / 0.0254
#    paraTemp = carrierGasMass * u * paraVSigma**2 / kb * 1e3
#    print('Beam longitudinal velocity standard diviation: ', abs(paraVSigma), ' +- ', stdParaVSigma, ' m/s')
#    print('Beam longitudinal temperature from multipoint measurement: ', paraTemp, ' mK')
    
    if plot and linearFit:
        plt.figure()
        plt.plot(position, tArrivalNoGausFit, '^', label = 'tof arrival w/o gaussian fit')
        plt.plot(position , tArrivalGausFit, '^', label= 'tof arrival w/ gaussian fit')
        plt.plot(position, np.poly1d(linearVNoFit)(position), '-')
        plt.plot(position, np.poly1d(linearVGausFit)(position), '-')
        plt.xlabel('position [in]')
        plt.ylabel('TOF arrival time [us]')
        plt.title('Beam tof VS measuring position')
        plt.legend()
        plt.show()
    elif plot:
        plt.figure()
        plt.plot(position, tArrivalNoGausFit, '^', label = 'tof arrival w/o gaussian fit')
        plt.plot(position , tArrivalGausFit, '^', label= 'tof arrival w/ gaussian fit')
        plt.xlabel('position [in]')
        plt.ylabel('TOF arrival time [us]')
        plt.title('Beam tof VS measuring position')
        plt.legend()
        plt.show()                        

    if calcTemp and linearFit:
        tArrivalNoGausFit = np.array(tArrivalNoGausFit)
        tArrivalGausFit = np.array(tArrivalGausFit)
        
        
        fig1, ax1 = plt.subplots()
        ax1.plot(position, fwhmDirect, '-*', label = 'fwhm no gaussian fit')
        ax1.plot(position, fwhmGaus,'-*', label = 'fwhm gaussian fit')
        
        t_sigma_Direct = tArrivalNoGausFit - fwhmDirect / (2 * np.sqrt(2 * np.log(2)))
        t_sigma_Gaus = tArrivalGausFit - fwhmGaus /(2 * np.sqrt(2 * np.log(2)))

        fit1,cov1 = np.polyfit(position, t_sigma_Direct, 1, cov = True)
        fit2, cov2 = np.polyfit(position, t_sigma_Gaus, 1, cov = True)
        v_sigma_Direct = 1 / fit1[0] * 0.0254 * 1e6 - linearSpeedNoFit
        v_sigma_Gaus = 1 / fit2[0] * 0.0254 * 1e6 - linearSpeedGausFit
        
        kb = 1.38e-23
        M =  1.66e-27 * gasMass
        paraT_Direct = M * v_sigma_Direct ** 2 / kb
        paraT_Gaus = M * v_sigma_Gaus **2 / kb
        print("Longitudinal temperature (no gaussian fit): ", paraT_Direct * 1e3, " mK")
        print("Longitudinal temperature (gaussian fit): ", paraT_Gaus * 1e3, " mK")
        fig2, ax2 = plt.subplots()
        ax2.plot(position, t_sigma_Direct, '*', label = 't_sigma no gaussian fit')
        ax2.plot(position, t_sigma_Gaus, '*', label = 't_sigma gaussian fit')
        ax2.plot(position, np.poly1d(fit1)(position), 'r-')
        ax2.plot(position, np.poly1d(fit2)(position), 'r-')
        plt.show()
        
        
        

def tofPlot(file, lowerBound = 0, upperBound = 0, hold = False, label = 'None', gainFile = 'None'):
    """
    - Function: [no return] = tofPlot([str] filt, [int]lowerBound = 0, [int]upperBound = 0, [bool]hold = False
                              [str]label = 'None')
    - Description: 
              This simple function is to simply plot the tof measurement data. Ideally
            only the file name (including path) is needed, other parameters are optional
              It also has feature that can auto find peak region if the peak exists, and 
            when ploting multiple tof data in one plot, simply set 'hold' to 'True' and 
            rerun this same function for different data. 
              If need label on plots, just assign string to 'label' in input
    - Input: 
            - file: [str] The file name including complete path to this file 
            - lowerBound: [int] lower bound of peak region. When both lower bound and 
                          upper bound are 0, the function will automatically find the peak region. 
                          Note that only use the auto peak finder when you are sure the peak exists.
                          Default: 0 
            - upperBound: [int] uppper bound of peak region. When both lower bound and 
                          upper bound are 0, the function will automatically find the peak region. 
                          Note that only use the auto peak finder when you are sure the peak exists.
                          Default: 0 
            - hold: [boolean] This feature enables plot on the same figure every time this function 
                          is called. Default: False            
            - label: [str] String that will be used for the plot legend.  If left as 'None' then
                          the legend will be absent
                          Default: 0            
            - gainFile: [str] If provided the RGA signal will be scaled by the appropriate gain
                          factor.  If absent no scaling will be applied to the signal
                          Default: 0
    """
    
    gain = 1
    data = np.loadtxt(file, skiprows = 50)
    lb, ub = autoFindPeakBounds(data) if (lowerBound + upperBound) == 0 else find_bounds_idx(data, lowerBound, upperBound)
    yOffset = np.average(data[ub:, 1])
    data = data[lb:ub, :]
    data[:,1]  = data[:,1] - yOffset
            
    if not hold:
        plt.figure()
    if gainFile != 'None':   
        gain = findGain(gainFile)
    plt.plot(data[:, 0] * 1e6, data[:, 1]/gain , label = label)
    plt.xlabel('Time of flight [us]')
    plt.ylabel('Signal [arb. unit]')
    if not label == 'None':
        plt.legend()
    if not hold:
        plt.show()


# New testing function      
def calcTransverseScan(path,  regStr= '-?\d+\.\d+in.lvm', lowerBound = 0, upperBound = 0, gaussianFit = True, plot=True):
    """
    Under testing!
    - Function: [no return] = calcTransverseScan([str]path,[str] regStr= '-?\d+\.\d+in.lvm',  [int]lowerBound= 0
                              [int]upperBound = 0, [bool]gaussianFit = True )
    - Description:
              This function deals with the transverse scan (main laser) to find the width of the beam. It implements
            the transvers scan data by plotting peak value at different positions and the intergrated peak value at 
            different positions. All position unit should be in inch.
              To index the data file, users only need to give a path and a regrlar expression str to find the position 
            value. 
              Additionally, user can specify the lower bound and upper bound of peak region or used the auto peak finder
            when both lowerBound and upperBound values are setted to 0. Only use auto peak finder when you are sure the 
            peak exists in the given file.
    - Input:
            - path: [str] path to the folder where transvers scan data was saved
            - regStr: [str] the regular expression to find the position value in the file names. By default, it's 
              '-?\d+\.\d+in.lvm
            - lowerBound: [int] lowerBound time of the peak region in micorseconds [us], set to 0 by default, 
                          if both lowerBound and upperBound are 0, then this function will call 'autoFindPeakBounds'
                          function to find the index of the lower and upper bounds, but one has to make sure that 
                          there is peak exists.
            - upperBound: [int] upperBound time of the peak region in micorseconds [us], set to 0 by default, 
                          if both lowerBound and upperBound are 0, then this function will call 'autoFindPeakBounds'
                          function to find the index of the lower and upper bounds, but one has to make sure that 
                          the peak exsits.
            - gaussianFit: [bool] Decide whether or not to fit the scan with a gaussain, by default, it's "True"
    - Output:
            - None
    """
    pos = findFileNameKeyNum(regStr, path)
    peakValue = []
    area = []
    
    
    for i, p in enumerate(pos):
          
        fileName = [x for x in os.listdir(path) if not re.findall('_'+str(p) + '0?in.lvm', x) == []][0]
        print("...loading ", fileName)
        data = np.loadtxt(path + fileName, skiprows = 35)
        lb, ub = autoFindPeakBounds(data) if (lowerBound + upperBound) == 0 else find_bounds_idx(data, lowerBound, upperBound)
        data = data[lb:ub, :]
        
        peakValue.append(np.max(data[:,1]))
        area.append(np.trapz(data[:,1], x = data[:,0]))
        
    pos =  np.array(pos)
    peakValue = np.array(peakValue)
    area = np.array(area)
    
    if gaussianFit:
        popt_peak, pcov_peak = gausFit(pos, peakValue)
        popt_area, pcov_area = gausFit(pos, area)
        
    if plot:  
        plt.figure()
        plt.plot(pos, peakValue, '^', label = 'raw data peak')
    
    fwhm = 0 
    if gaussianFit:
        fwhm = 2 * np.sqrt(2 * np.log(2)) * popt_peak[2]        
        print("Gaussian fit peak center: ", popt_peak[1], " in")
        print("Gaussian fit FWHM: ", fwhm, ' in')
        if plot:
            plt.plot(pos, gaus(pos, *popt_peak), '-', label = 'gaussian fit')
    if plot:
        plt.legend()
        plt.xlabel('Position [in]')
        plt.ylabel('Signal [arb. unit]')
        plt.title('Transvers scan peak signal at different positions')
        
#    plt.figure()
#    plt.plot(pos, area, '^', label = 'raw data area')
#    if gaussianFit:
#        plt.plot(pos, gaus(pos, *popt_area), '-', label = 'gaussian fit')
#        print("Gaussian fit peak center: ", popt_area[1], " in")
#        print("Gaussian fit FWHM: ", 2 * np.sqrt(2 * np.log(2)) * popt_area[2], ' in')
#    plt.legend()
#    plt.xlabel('Position [in]')
#    plt.ylabel('Integrated signal [arb. unit]')
#    plt.title('Transvers scan integrated signal at different positions')
        plt.show()
    return fwhm
    
def laserFreqScan(path, regStr = '-?\d+MHz.lvm', lowerBound = 0, upperBound = 0, fitTOF = False, fitScan = True, invert = False, keyWordUnit='MHz', plot=True, returnData = False):
    """
    - Function: [float]fwhm = laserAbsScan([str]path, [str]regStr, [int]lowerBound, [int]upperBound, [bool]plot, [str]label
    - Description: 
              - This function is to plot the laser frequence scan measurement of the beam, not that the peak has to be positive.
                it searches the frequency in the filename, and find the peak value in each of the data file, plot the peak value
                VS frequency plot, and (optional) do a gaussian fit to this plot. return the fwhm.
    - Input: 
            - path: [str] folder path for stored data
            - regStr: [str] regular expression to search for the frequency value in the file name, default: '\d+Mhz.lvm'
            - lowerBound: [int] data peak region lower bound in us. By default its using autoFindPeakBounds function 
            - upperBound: [int] data peak region lower bound in us. By default its using autoFindPeakBounds function 
            - plot: [bool] Decide whether or not plot the data. Default 'True'
            - label: [str] data plot label, by default '' then label will not by plotted, otherwise the given label will be plotted.
    - Output:
            - fwhm: FWHM of the gaussian fitting, by default its 0, only gives non-zero value if gaussianFit = True
    """
    
    freq = findFileNameKeyNum(path = path, regStr=regStr)
    area = [] 
    peak = []
    for f in freq:
        fileName = [x for x in os.listdir(path) if not re.findall('_' + str(f) + keyWordUnit + '.*.lvm', x) == []][0]
        data = np.loadtxt(path + fileName, skiprows=30)
        lb,ub = find_bounds_idx(data, lowerBound, upperBound)
        offset = np.average(data[ub:ub + 50, 1])
        data = data[lb:ub,:]
        data[:,1] = data[:,1] - offset
        if invert:
            data[:,1] = -data[:,1]
        area.append(np.trapz(data[:,1], x = data[:,0]*1e6))
        if fitTOF:
            popt, pcov = gausFit(x = data[:,0], y = data[:,1])
            peak.append(popt[0])
        else:
            peak.append(max(data[:,1]))

    fig = plt.figure()
    ax1 = fig.add_subplot(211)
    ax1.plot(freq, peak, '^', label = 'peak')
    ax1.set_xlabel('Frequence detune [MHz]')
    ax1.set_ylabel('peak signal [arb. unit]')
    ax2 = fig.add_subplot(212)
    ax2.plot(freq, area, '>', label = 'area')
    ax2.set_xlabel('Frequence detune [MHz]')
    ax2.set_ylabel('integrated signal [arb. unit]')

    if fitScan:
        popt_peak, pcov_peak = gausFit(x = freq, y = peak )
        popt_area, pcov_area = gausFit(x = freq, y = area)
        ax1.plot(freq, gaus(freq, *popt_peak), '--', label = 'gaussian fit\nFWHM:'+ str(2*np.sqrt(2 * np.log(2)) * popt_peak[2])[:4] + keyWordUnit)
        ax2.plot(freq, gaus(freq, *popt_area), '--', label = 'gaussian fit\nFWHM:'+ str(2*np.sqrt(2 * np.log(2)) * popt_area[2])[:4] + keyWordUnit)
        ax1.legend()
        ax2.legend()
    plt.show()
    
    if returnData:
        return (freq, peak, area)
    
def laserFreqScan_old(path, regStr = '\d+MHz.lvm', lowerBound = 0, upperBound = 0, plot = True, fitTOF = False, fitScan = True,  label = ''):
    """
    - Function: [float]fwhm = laserAbsScan([str]path, [str]regStr, [int]lowerBound, [int]upperBound, [bool]plot, [str]label
    - Description: 
              - This function is to plot the laser frequence scan measurement of the beam, not that the peak has to be positive.
                it searches the frequency in the filename, and find the peak value in each of the data file, plot the peak value
                VS frequency plot, and (optional) do a gaussian fit to this plot. return the fwhm.
    - Input: 
            - path: [str] folder path for stored data
            - regStr: [str] regular expression to search for the frequency value in the file name, default: '\d+Mhz.lvm'
            - lowerBound: [int] data peak region lower bound in us. By default its using autoFindPeakBounds function 
            - upperBound: [int] data peak region lower bound in us. By default its using autoFindPeakBounds function 
            - plot: [bool] Decide whether or not plot the data. Default 'True'
            - label: [str] data plot label, by default '' then label will not by plotted, otherwise the given label will be plotted.
    - Output:
            - fwhm: FWHM of the gaussian fitting, by default its 0, only gives non-zero value if gaussianFit = True
    """
    



    freq = findFileNameKeyNum(regStr, path)
    peak = []
    for f in freq:
        fileName = [x for x in os.listdir(path) if not re.findall('_' + str(f) + 'MHz.lvm', x) == []][0]
        data = np.loadtxt(path + fileName, skiprows=30)
        lb, ub = find_bounds_idx(data, lowerBound, upperBound) if (lowerBound + upperBound) > 0 else autoFindPeakBounds(data)
        data = data[lb:ub, :]
    
        if fitTOF:
            popt0,pcov0 = gausFit(data[:,0], data[:,1])
            peak.append(popt0[0])
        else:
            peak.append(max(data[:,1]))

    freq = np.array(freq)
    peak = np.array(peak)
    fwhm = 0

    plt.figure()
    plt.plot(freq, peak,'*', label  = label)
    plt.title('Laser frequency scan, peak fit')
    plt.tight_layout()
    plt.xlabel('Frequency [MHz]')
    plt.ylabel('Signal [arb. unit]')
    plt.title('Laser frequency scan, peak')
        
    if fitScan:
        popt1, pcov1 = gausFit(freq,peak)        
        fwhm = 2 * np.sqrt(2 * np.log(2)) * popt1[2]
        plt.plot(freq, gaus(freq, *popt1), '-')
        print('FWHM: ', fwhm, 'MHz, Resonant frequency: ', popt1[1], ' MHz')
    
    if not label == '':
        plt.legend()
    
    
    plt.show()



# Added on 20170901
def entrainParaScanTOF(path, keyNumReStr, lowerBound, upperBound, returnResult ,  keyNumName = ' ',keyNumUnit = ' '):
    """
    - Function: [list]keynum, [array]peak, [array]area, [array]fwhm, [array]tof = entrainParaScanTOF(
    [str]path, [str]keyNumReStr, [int]lowerBound, [int]upperBound, [bool]returnResult, [str]keyNumName=' ', [str]keyNumUnit=' ')
    
    - Description: 
              This function is to plot the time-of-flight measurement of all kinds of numerical parameter scan.
              User has to make sure the files are in a specific isolated folder, providing a path to the folder 
              and the regular expression for the scanning parameter, the function will automatically find the .lvm files 
              and the numerical scanning parameters. 
              
              The function plots 2 figures:
                  - Raw time of flight plot for all scanned parameters
                  - A plot with 4 subplots:
                       + Peak value VS scanned parameters
                       + Integrated signal (area) VS scanned parameters
                       + Peak fwhm VS scanned parameters
                       + Peak arrival time VS scanned parameters
              
             Note: This function DOES NOT support gain, so if your data has different gains, don't use this, and this function 
                    only plot on raw data w/o considering gain faxtor.
    - Input:
            - path: [str] folder path for the data set
            - keyNumRestr: [str] Regular expression string for indexing the key number, e.g. "delay_\d+us.lvm"
            - lowerBound: [int] peak region lowerBound time in microseconds
            - upperBound: [int] peak region upperBound time in microseconds 
            - returnResult: [bool] If true, return a tuple ([list]keyNum, [array]peak, [array]area, [array]fwhm, [array]tof), else only plot no return
            - keyNumName: [str] The name of scanned parameters, used for plot labelling. e.g. 'ribbon delay', default = ' '
            - keyNumUnit: [str] The unit of scanned parameters, used for plto labelling. e.g. 'us', default = ' '
    - Output:
            There is return only if the input parameter returnResult is set to 'True'
            - tuple(
            [list]keyNum,
            [array]peak, 
            [array]area, 
            [array]fwhm, 
            [array]tof
            )
    
    """
    keyNum = findFileNameKeyNum(keyNumReStr, path)
    peak = []
    area = []
    sigma = []
    tof = []

    fig0, ax0 = plt.subplots(figsize = (12, 5))
    for n in keyNum:
        
        filename = [f for f in os.listdir(path) if not re.findall('_' + str(n) + '.+lvm', f) == []][0]
        data = np.loadtxt(path + filename, skiprows=30)
        lb, ub = find_bounds_idx(data, lowerBound, upperBound) if (lowerBound + upperBound) > 0 else autoFindPeakBounds(data)
        #offset = np.average(data[ub:ub+50,1]) # Only average peak-nearby region
        offset = np.average(data[lb-30:lb,1]) # Only average peak-nearby region

        data = data[lb:ub, :]
        data[:,1] = data[:,1] - offset # remove offset
        ax0.plot(data[:,0]*1e6, data[:,1], label =keyNumName + ' ' +  str(n) +' ' + keyNumUnit)
        peak.append(max(data[:,1]))
        area.append(np.trapz(data[:,1], x = data[:,0]))
        popt, pcov = gausFit(x = data[:,0], y = data[:,1])
        sigma.append(popt[2])
        tof.append(data[np.argmax(data[:,1]), 0])
 
        
    plt.legend()
    plt.title('Time of flight measurement')
    ax0.set_xlabel('Time of flight [us]')
    ax0.set_ylabel('Fluorescence signal [arb. units]')

    peak = np.array(peak)
    area = np.array(area)
    sigma = np.array(sigma)
    tof = np.array(tof)


    fig1 = plt.figure(figsize=(10,8))
    #plt.title('Hafnium ribbon voltage scan fluorescence before slower (Noz pulse length = 7.5 us)')

    ax1 = fig1.add_subplot(221)
    ax1.plot(keyNum, peak, '*-', label = 'peak')
    ax1.set_ylabel('Peak signal')
    ax1.set_xlabel(keyNumName + '[' + keyNumUnit + ']')
    ax1.set_title('Time of flight Peak signal')
    plt.legend()

    ax2  = fig1.add_subplot(222)
    ax2.set_title('Time of flight integrated signal')
    ax2.plot(keyNum, area, '*-', label = 'area')
    ax2.set_ylabel('integrated signal ')
    ax2.set_xlabel(keyNumName + '[' + keyNumUnit + ']')
    plt.legend()

    ax3 = fig1.add_subplot(223)
    ax3.plot(keyNum, sigma * 2 * np.sqrt(2 * np.log(2)) * 1e6,'*-', label = 'fwhm')
    ax3.set_ylabel('pulse fwhm [us]]')
    ax3.set_xlabel(keyNumName + '[' + keyNumUnit + ']')
    ax3.set_title('Time of flight FWHM')
    plt.legend()


    ax4 = fig1.add_subplot(224)
    ax4.plot(keyNum, tof * 1e6,'*-', label = 'tof')
    ax4.set_ylabel('Time of flight [us]')
    ax4.set_xlabel(keyNumName + '[' + keyNumUnit + ']')
    ax4.set_title('Time of flight arrival time')
    plt.legend()

    plt.tight_layout()
    plt.show()
    
    if returnResult:
        return (keyNum, peak, area, sigma, tof)



def load3dData(path, regStr, lowerBound, upperBound):
    '''
    - Function [1d array]x, [1d array]y, [list of 1d array]z = load3dData([str]path, [str]regStr, [int]lowerBound, [int]upperBound)
    - Description:
            This function loads any parameter scan tof files(e.g. wire scan) as a 3D surface data sets. No extral data processing
          is included. See output for details. 
            This function mean to use with func plotly3d_surface to generate an interactive 3d surface plot.
    - Input:
            - [str]path: folder path for target data sets 
            - [str]regStr: regular expression string for key number indexing 
            - [int]lowerBound: time lower boundrary value of interest
            - [int]upperBound: time higher boundrary value of interest
    - Output:
            - [1d array]x: array of time for the general tof 
            - [1d array]y: array of scan parameters(e.g. wire position) 
            - [list of 1d array]z: 2d array of surface, z.shape == (len(x), len(y)). For example, for wire scan, z is the tof value 
              appended to a list.
    
    '''
    keyWd = findFileNameKeyNum(path = path, regStr = regStr)
    x = keyWd
    z = []
    for i, key in enumerate(keyWd):
        file = [x for x in os.listdir(path) if not re.findall('_' + str(key) + '\w*.lvm$', x) == []][0]
        data = np.loadtxt(path + file, skiprows = 30)
        lb, ub = find_bounds_idx(data, lowerBound, upperBound)
        offset = np.mean(data[ub:ub+30, 1])
        data = data[lb:ub, :]
        data[:,1] = data[:,1] - offset
        if i == 0:
            y = data[:,0]
        z.append(data[:,1])
    return (x, y, z)



def plotly3d_surface(z, x, y, nticks = 5, xtitle = '', ytitle = ''):
    '''
    - Function: [no return] = plotly3d_surface([2d arrary]z, [1d array]x, [1d array]y, [int]nticks = 5, [str]xtitle = '', [str]ytitle = '')
    - Description:
            This is a plotting function that uses plotly package to generate interactive 3D surface plot. Required packages is plotly
    - Input:
            - [2d array]z: The z value, usually the surface value of the surface plot, z.shape = (len(x), len(y))
            - [1d array]x: The x axis value of the surface plot
            - [1d array]y: The y axis value of the surface plot
            - [int] nticks: number of ticks on x and y axis. 
            - [str] xtitle: x axis title 
            - [str] ytitle: y axis title
    - Output:
            - Interactive plotly 3D plot
    '''
    
    import plotly.offline as py
    import plotly.graph_objs as go
    py.init_notebook_mode(connected = True)
    trace = dict(
        z = z,
        x = x,
        y = y,
        type = 'surface',
        #colorscale = 'Jet',
        )
    layout = go.Layout(
        scene = dict(
            xaxis = dict(
                title = xtitle   
            ),
            yaxis = dict(
                title = ytitle
            )
        )
    )
    
    fig = go.Figure(data = [trace], layout = layout)
    py.iplot(fig, filename='3D surface plot')



def plotAllInFolder(path, lowerBound=0, upperBound=0, singleFigure = False):
    '''
    - Function: [no return] = plotAllInFolder([str]path, [int]lowerBound, [int]upperBound)
    - Description:
             This function is to plot all tof data in a single folder, on seperate figures, with sorted sequence.
             I f lowerBound/upperBound is specified, then plot the data in the specified time interval, otherwise 
             plot the whole range. Plotted data is raw data, without any extral data processing.
             
             WARNING: THIS FUNCTION COULD GENERATE A LOT OF FIGURES !
    - Input: 
            - [str]path: path of the folder for plotting 
            - [str]lowerBound: time interval lowerBound 
            - [str]upperBound: time interval upperBound 
    - Output: 
            - all tof plots on seperate figures
    '''
    print("Start plotting all tof figures in folder:  ", path)
    print("\nWARNING: A GROUP OF FIUGRES ARE APPROACHING ...\n")
    time.sleep(5)
    for i, file in enumerate(sorted(os.listdir(path))):
        try:
            data = np.loadtxt(path + file, skiprows=30)
            
            if upperBound:
                lb, ub = find_bounds_idx(data, lowerBound, upperBound)
                data = data[lb:ub, :]
            else: 
                pass
            
            if singleFigure:
                if i == 0:
                    plt.figure()
            else:
                plt.figure()
                print('***Filename:', file)
            plt.plot(data[:,0] * 1e6, data[:,1], '*')
            
            if not singleFigure:
                plt.show()
        except ValueError:
            pass   
    if singleFigure:
        plt.show()
        

def calcScanningLaser_notUsed(path, config, lowerBound, upperBound, plot = False, image = False,regStr = '\d+\.\d*in',
                       fitTOF = False, fitScan = False, stepSize = 0.0315, beamVelocity = 0,
                       debug = False, timePlot = False, subtractBackground=False, noiseFilter = False, lowFreq = 0, highFreq = 1e4, 
                       cscale=(None, None), invert = False):
    """
    - Function: [float]entrainNum = calcWireEntrainNum([str]path, [str]config, [int]lowerBound, [int]upperBound
                                    [bool]plot = False, [bool]image = Flase, [bool]fit = False, [float]beamVelocity = 0,
                                    [tuple]cscale = (None, None))
    - Description: 
              This function is used with the wire scan data. It calculates the entrainment number
            for a wire scan measurement. All of the files have to be in a single folder, and this 
            folder should contain no other files from other measuremnt, otherwise the auto indexing 
            will be messed up. 
              It automatically finds the wire scan data file and the position of the corresponding 
            wire position (in inches), by using regular expression. It also automatically find the 
            gain of measurment by looking into the 'config' file. Based on measurement data, gain,
            ionization probality and detection probality. 
              The function provides optional parameters, users can decided if they want to plot the 
            scan result, scan image, fit gaussain or not. 
    - Input: 
            - path: [str] The path to the folder which has wire scan data 
            - config: [str] The config file which has measurement parameters, especially gain info.
            - lowerBound: [int] The lowerBound of data peak region in terms of micorseconds [us].
            - upperBound: [int] The upperBound of data peak region in terms of microseconds [us].
            - plot: [bool] Optional, decide wether to plot result or not.
                    True for plot, False (default) for no plot
            - image: [bool] Optional, decide wether or not plot imaging of the wire scan.
                     Note: in order to plot image, the value of 'plot' has to be set to 'True'.
                     True for ploting the image, False(default) for not ploting the image
            - fitScan: [bool] Decide wether to fit the wire scan with gaussian or not 
                   True to fit with gaussian, False(default) to not fit 
            - fitTOF: [bool] Decide wether to fit the tof signal for a single wire measurement with 
                   gaussian. By default its 'False'
            - stepSize: [float] inches, stepsize of the wire scan, default 0.0315 in
            - beamVelocity: [float] Optional, velocity of beam. This is used to add another axis 
                            on the image plot, to show the actually size of the cloud. If it is 
                            setted to 0(default), then this additional axis will not be added.
            - cscale: [tuple] Optional, lower and upper bound of image color bar, default is 
                      imshow default (min and max of data). Use elements of `None` inside the tuple 
                      for partial default.
    - Output: none                                              
    """
    

    pos = findFileNameKeyNum(regStr, path)
    entrainNum = np.zeros((len(pos), 2))
    entrainNum[:,0] = pos
    
    for i, p in enumerate(pos):
        fileName = [x for x in os.listdir(path) if not re.findall('.*_WIRE_'+str(p) + '.+lvm', x) == []][0]
        if debug:
            print('loading file: ' + fileName + '...')
        try:
            data = np.loadtxt(path + fileName, skiprows = 50)
        except ValueError:
            print("Probelmatic file: ", fileName)
            raise ValueError
        lb, ub = find_bounds_idx(data, lowerBound, upperBound)
        tStep = data[1,0] - data[0,0]
        
        # remove initial offset
        yOffset = np.average(data[lb - 30: lb, 1])
        #yOffset = np.average(data[lb - 20: lb, 1] + data[ub: ub+20, 1])
        data[:,1] = data[:,1] - yOffset
       
        #if subtractBackground:
           # data = backgroundSubtract(data, ub, -1)
       
        data = data[lb:ub, :]
        
        if noiseFilter:
            data = bandPassFilter(data, tStep = tStep, lowFreq = lowFreq, highFreq = highFreq) 
        
        if invert:
            data[:,1] = -data[:,1]
        if fitTOF:
            popt_tof, pcov_tof = gausFit(data[:,0], data[:,1])
            #inteTOF = integrate.quad(lambda x:gaus(x, *popt_tof)/0.0315, data[0,0], data[-1,0])[0]
            inteTOF = integrate.quad(lambda x:gaus(x, *popt_tof), data[0,0], data[-1,0])[0]                    
        entrainNum[i,1] = inteTOF

        totEntrainNum = entrainNum[:,1].sum()
                
        if image:

            if i == 0:
                imagePlot = np.zeros([len(pos), ub - lb])                
                imagePlot[i, :] = data[:,1]
            else:                
                imagePlot[i, :] = data[:,1]
                
        if timePlot:
            if i == 0:
                timeSum = data
            else:
                timeSum[:,1] = timeSum[:,1] + data[:,1]
    
    if subtractBackground:
        print("\n**NOTE**: background subtraction is ON!")
        
    if noiseFilter:
        print("\n**NOTE**: noise band pass filter is ON!")
    # supplementary functions
    if fitScan:
        popt, pcov = gausFit(entrainNum[:,0], entrainNum[:,1])
        gausStart = popt[1] - 4 * popt[2] # 4 sigma
        gausEnd = popt[1] + 4 * popt[2] # 4 sigma 
        inteEntrainNum = integrate.quad(lambda x:gaus(x, *popt)/0.0315, gausStart, gausEnd)[0]
        print("\n=================================================")
        print('Integrated atom num (Gaussian 4 sigma): ', '{:2E}'.format(inteEntrainNum))
        print("Beam transverse center(Gaussian fit): {:1.3f} in".format(popt[1]))
        print('Beam FWHM (Gaussian fit): {a:1.3f} in'.format(a=2*np.sqrt(2 * np.log(2)) * popt[2]))
        print("=================================================")
        
    if plot:
        plt.figure()
        plt.plot(entrainNum[:,0], entrainNum[:,1], 'o', label = 'raw data\n' + str('{:.2e}'.format(totEntrainNum)))
        plt.xlabel('Laser scan position [in]')
        plt.ylabel('Integrated TOF signal')
        plt.title('Scanning Laser Measurement')
        if fitScan:
            gpos = np.linspace(gausStart, gausEnd, 100)
            plt.plot(gpos, gaus(gpos, *popt), 'r-', label = 'gaussian fit (4 sigma)\n' + str('{:.2e}'.format(inteEntrainNum)))
        plt.legend()

    
    if image:
        fig1 = plt.figure()
        ax1 =fig1.add_subplot(111)
        cax = ax1.imshow(imagePlot, 
                         extent = [data[0, 0] * 1e6, data[-1,0] * 1e6, pos[-1],pos[0] ],
                         aspect = 'auto',
                         cmap = 'jet',
                         vmin = cscale[0],
                         vmax = cscale[1])
        ax1.set_xlabel('Time of flight [us]')
        ax1.set_ylabel('Laser vertical position[in]')
        
        cbar = fig1.colorbar(cax)
        cbar.set_label('Fluorescence signal')
        if beamVelocity > 0:
            ax2 = ax1.twiny()
            ax2.set_xlim([0,  (data[-1,0] - data[0,0]) * beamVelocity * 1e3])
            ax2.set_xlabel(' Z position [mm]')
    
    if timePlot:
        fig2, ax2 = plt.subplots()
        ax2.plot(timeSum[:,0]*1e6, timeSum[:,1], '*-')
        ax2.set_xlabel('Time[us]')
        ax2.set_ylabel('Position summed signal')
        ax2.set_title('Scanning laser time plot with sum on wire position')
        
    if fitScan or plot or image or timePlot:
        plt.show()
        
    if timePlot:
    
        return entrainNum, timeSum
    else:
        return entrainNum
    


@warningMuter
def calcScanningLaser(path,lowerBound, upperBound, config=0, image = True, fitScan = True,
                      keyNumName = 'Laser vertical position', keyNumUnit = 'in', keyNumRegStr = '(\d+\.\d*)in',
                      plotSelect = 'all',  removeOffset = True, invert = False, noiseFilter = False,
                      cscale = (None, None), beamVelocity = 0, debug = False, lowFreq = 0, highFreq = 5e4,
                      substractBackground = False, returnResult = False, returnData = False):
    
    keyNum = np.array(findFileNameKeyNum(keyNumRegStr, path))

    peak = []
    area = []
    sigma = []
    tof  = []

    for i, p in enumerate(keyNum):
        
        #fileName = [x for x in os.listdir(path) if not re.findall(str(p) + keyNumUnit + '.*\.lvm$', x) == []][0]
        #fileName = [x for x in os.listdir(path) if not re.findall('_'+str(p) + '.*\.lvm$', x) == []][0]
        d, r = keyNumRegStr.split('(')
        r, s = r.split(')')
        R = d + '{}0*?'+s
        fileName = [x for x in os.listdir(path) if not re.findall(R.format(p).replace('.', '\.') + '.*\.lvm$', x) == []][0]
        if debug:            
            print('position: {}'.format(p))
            print(R.format(p))
            print('loading file: '+ fileName + '...')
        try:
            #data = np.loadtxt(path + fileName, skiprows=50)
            data = np.fromfile(path + fileName, sep = '\t').reshape(-1, 2)
        except ValueError:
            print('File name not found or file cotent is not pure number (line 50+)')
            raise ValueError
        lb, ub = find_bounds_idx(data, lowerBound, upperBound)
#        if substractBackground:
#            data = backgroundSubtract(data, ub, -1)           
        if removeOffset:
            yOffset = np.average(data[lb-30:lb, 1])
            data[:,1] = data[:,1] - yOffset
        if invert:
            data[:,1] = -data[:,1]
        if noiseFilter:
            tStep = data[1,0] - data[0,0]
            data = bandPassFilter(data, tStep = tStep, lowFreq = lowFreq, highFreq = highFreq)

        data = data[lb:ub, :]

        if image:
            if i == 0:
                imagePlot = np.zeros([len(keyNum), ub - lb])
                imagePlot[i, :] = data[:,1]
            else:
                imagePlot[i, :] = data[:,1]


        peak.append(max(data[:,1]))
        area.append(np.trapz(data[:,1], x = data[:,0]))
        popt, pcov = gausFit(x = data[:,0], y = data[:,1])
        sigma.append(popt[2])
        tof.append(data[np.argmax(data[:,1]), 0])

    peak = np.array(peak)
    area = np.array(area)
    sigma = np.array(sigma)
    tof = np.array(tof) 
    
    # Set canvas size based on plotSelect
    if plotSelect in ['all', 'All']:
        fig1 = plt.figure(figsize=(10,8))
    elif image:
        fig1 = plt.figure()
    else:
        pass

    # Plotting based on plotSelect
    if plotSelect in ['all', 'All', 'peak', 'Peak']:
        if plotSelect in ['all', 'All']:
            ax1 = fig1.add_subplot(221)
        else:
            ax1 = fig1.add_subplot(111)
        ax1.plot(keyNum, peak, '*', label = 'peak')
        if fitScan:
           popt, pcov = gausFit(keyNum, peak)
           gausStart = popt[1] - 4 * popt[2] # 4 sigma
           gausEnd = popt[1] + 4 * popt[2] # 4 sigma 
           inteEntrainNum = integrate.quad(lambda x:gaus(x, *popt), gausStart, gausEnd)[0]
           print("\n=================================================")
           print("Integrated gaussian fitting area: {}".format(inteEntrainNum))
           print("Beam transverse center(Gaussian fit): {:1.3f} in".format(popt[1]))
           print('Beam FWHM (Gaussian fit): {a:1.3f} in'.format(a=2*np.sqrt(2 * np.log(2)) * popt[2]))
           print("=================================================")
           gpos = np.linspace(gausStart, gausEnd, 100)
           ax1.plot(gpos, gaus(gpos, *popt), 'r-', label = 'gaussian fit' )
        ax1.set_ylabel('Peak signal')
        ax1.set_xlabel(keyNumName + '[' + keyNumUnit + ']')
        ax1.set_title('Time of flight Peak signal')
        plt.legend()
    
    if plotSelect in ['all', 'All', 'area', 'area', 'integrate', 'Integrate']:
        if plotSelect in ['all', 'All']:
            ax2 = fig1.add_subplot(222)
        else:
            ax2 = fig1.add_subplot(111)        
        ax2.plot(keyNum, area, '*', label = 'area')
        if fitScan:
          popt, pcov = gausFit(keyNum, area)
          gausStart = popt[1] - 4 * popt[2] # 4 sigma
          gausEnd = popt[1] + 4 * popt[2] # 4 sigma 
          inteEntrainNum = integrate.quad(lambda x:gaus(x, *popt), gausStart, gausEnd)[0]
          print("\n=================================================")
          print("Integrated gaussian fitting area: {}".format(inteEntrainNum))
          print("Beam transverse center(Gaussian fit): {:1.3f} in".format(popt[1]))
          print('Beam FWHM (Gaussian fit): {a:1.3f} in'.format(a=2*np.sqrt(2 * np.log(2)) * popt[2]))
          print("=================================================")
          gpos = np.linspace(gausStart, gausEnd, 100)
          ax2.plot(gpos, gaus(gpos, *popt), 'r-', label = 'gaussian fit')
        ax2.set_ylabel('integrated signal ')
        ax2.set_xlabel(keyNumName + '[' + keyNumUnit + ']')
        ax2.set_title('Time of flight integrated signal')
        plt.legend()
        
    if plotSelect in ['all', 'All', 'fwhm', 'FWHM']:
        if plotSelect in ['all', 'All']:
            ax3 = fig1.add_subplot(223)
        else:
            ax3 = fig1.add_subplot(111)  
        ax3.plot(keyNum, sigma * 2 * np.sqrt(2 * np.log(2)) * 1e6,'*-', label = 'fwhm')
        ax3.set_ylabel('pulse fwhm [us]]')
        ax3.set_xlabel(keyNumName + '[' + keyNumUnit + ']')
        ax3.set_title('Time of flight FWHM')
        plt.legend()

    if plotSelect in ['all', 'All', 'tof', 'TOF']:
        if plotSelect in ['all', 'All']:
            ax4 = fig1.add_subplot(224)
        else:
            ax4 = fig1.add_subplot(111)  
        ax4.plot(keyNum, tof * 1e6,'*-', label = 'tof')
        ax4.set_ylabel('Time of flight [us]')
        ax4.set_xlabel(keyNumName + '[' + keyNumUnit + ']')
        ax4.set_title('Time of flight arrival time')
        plt.legend()
    
    

    if image:
        fig5 = plt.figure()
        ax5 =fig5.add_subplot(111)
        cax = ax5.imshow(imagePlot, 
                         extent = [data[0, 0] * 1e6, data[-1,0] * 1e6, keyNum[-1],keyNum[0] ],
                         aspect = 'auto',
                         cmap = 'jet')
        ax5.set_xlabel('Time of flight [us]')
        ax5.set_ylabel('Laser X position [in]')
        cbar = fig5.colorbar(cax)
        cbar.set_label('Atom number')
        if beamVelocity > 0:
            ax6 = ax5.twiny()
            ax6.set_xlim([0,  (data[-1,0] - data[0,0]) * beamVelocity * 1e3])
            ax6.set_xlabel(' Z position [mm]')
        plt.tight_layout()
        plt.show()

    if returnResult and returnData:
        times = data[:,0]
        return (keyNum, peak, area, sigma, tof, imagePlot, times)
    elif returnResult:
        return (keyNum, peak, area, sigma, tof)
#TODO:
# 1. Add color configurable paras
#     

def linePlotInOne(*args, **kwargs):
    try:
        labels = kwargs['labels']
    except KeyError:
        print("[*] NO Data labels provided !")
        raise KeyError
    try:
        offset = kwargs['offset']
    except KeyError:
        offset = 0
        pass
    try:        
        fig0, ax0 = plt.subplots(figsize = kwargs['figsize'])
    except KeyError:
        fig0, ax0 = plt.subplots()
        pass


    
    if len(args) == 1: 
    
        # input[ [line1_x, line1_y], [line2_x, line2_y], ..... ]
        try: 
            numDataSets = len(args[0])
            for i, line in enumerate(args[0]):
                if len(line) == 2:
                    valueX = line[0][:len(line[1])]
                    valueY = line[1]
                    ax0.plot(valueX, valueY + offset * i, '*', label = labels[i], color=plt.cm.jet(int((i+1)/numDataSets*255)))
                    popt, pcov = gausFit(x=valueX, y=valueY )
                    ax0.plot(valueX, gaus(valueX, *popt) + offset * i,'--', linewidth = 1, color=plt.cm.jet(int((i+1)/numDataSets*255)))
                else:
                    raise ValueError            
        except ValueError:
            pass        
        else:
            legendColNum = numDataSets // 11 + 1 
            ax0.legend(loc='upper left', bbox_to_anchor=(1.05, 1), ncol = legendColNum)      
            plt.show()
            return 
    else:
        # input [line1_x, line2_x, ....], [line1_y, line2_y, ...]
        try: 
            numDataSets = len(args[0])
            for i,x, y in zip(range(len(args[0])), args[0], args[1]):               
                valueY = y
                valueX = x[:len(valueY)]
                ax0.plot(valueX, valueY + offset * i, '*', label = labels[i], color=plt.cm.jet(int((i+1)/numDataSets*255)))
                popt, pcov = gausFit(x=valueX, y=valueY )
                ax0.plot(valueX, gaus(valueX, *popt) + offset * i,'--', linewidth = 1, color=plt.cm.jet(int((i+1)/numDataSets*255)))
        except ValueError:
            pass
        else:
            #ax0.legend()
            legendColNum = numDataSets // 11 + 1 
            ax0.legend(loc='upper left', bbox_to_anchor=(1.05, 1), ncol = legendColNum)      
            plt.show() 
            return  
        #input line_X, [line1_y, line2_y, .....]
        try: 
            numDataSets = len(args[1])
            for i,lineY in enumerate(args[1]):
                valueY = lineY
                valueX = args[0][:len(valueY)]              
                ax0.plot(valueX, valueY + offset * i, '*', label = labels[i],color=plt.cm.jet(int((i+1)/numDataSets*255)))
                popt, pcov = gausFit(x=valueX, y=valueY )
                ax0.plot(valueX, gaus(valueX, *popt) + offset * i,'--', linewidth = 1, color=plt.cm.jet(int((i+1)/numDataSets*255)))
             
        except ValueError:
            pass   
        else:
            legendColNum = numDataSets // 11 + 1 
            ax0.legend(loc='upper left', bbox_to_anchor=(1.05, 1), ncol = legendColNum)      
            plt.show() 
            return
   



       
if __name__ == '__main__':
    man()

    
